// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_2eproto;
class MitionPoint;
class MitionPointDefaultTypeInternal;
extern MitionPointDefaultTypeInternal _MitionPoint_default_instance_;
class MitionStatus;
class MitionStatusDefaultTypeInternal;
extern MitionStatusDefaultTypeInternal _MitionStatus_default_instance_;
class OriginPoint;
class OriginPointDefaultTypeInternal;
extern OriginPointDefaultTypeInternal _OriginPoint_default_instance_;
class RobotDrive;
class RobotDriveDefaultTypeInternal;
extern RobotDriveDefaultTypeInternal _RobotDrive_default_instance_;
class RobotInfo;
class RobotInfoDefaultTypeInternal;
extern RobotInfoDefaultTypeInternal _RobotInfo_default_instance_;
class RobotMap;
class RobotMapDefaultTypeInternal;
extern RobotMapDefaultTypeInternal _RobotMap_default_instance_;
class RobotPos;
class RobotPosDefaultTypeInternal;
extern RobotPosDefaultTypeInternal _RobotPos_default_instance_;
class RobotRequest;
class RobotRequestDefaultTypeInternal;
extern RobotRequestDefaultTypeInternal _RobotRequest_default_instance_;
class RobotResponse;
class RobotResponseDefaultTypeInternal;
extern RobotResponseDefaultTypeInternal _RobotResponse_default_instance_;
class RobotTrail;
class RobotTrailDefaultTypeInternal;
extern RobotTrailDefaultTypeInternal _RobotTrail_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::MitionPoint* Arena::CreateMaybeMessage<::MitionPoint>(Arena*);
template<> ::MitionStatus* Arena::CreateMaybeMessage<::MitionStatus>(Arena*);
template<> ::OriginPoint* Arena::CreateMaybeMessage<::OriginPoint>(Arena*);
template<> ::RobotDrive* Arena::CreateMaybeMessage<::RobotDrive>(Arena*);
template<> ::RobotInfo* Arena::CreateMaybeMessage<::RobotInfo>(Arena*);
template<> ::RobotMap* Arena::CreateMaybeMessage<::RobotMap>(Arena*);
template<> ::RobotPos* Arena::CreateMaybeMessage<::RobotPos>(Arena*);
template<> ::RobotRequest* Arena::CreateMaybeMessage<::RobotRequest>(Arena*);
template<> ::RobotResponse* Arena::CreateMaybeMessage<::RobotResponse>(Arena*);
template<> ::RobotTrail* Arena::CreateMaybeMessage<::RobotTrail>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum RobotDrive_Mode : int {
  RobotDrive_Mode_FREE = 0,
  RobotDrive_Mode_PAUSE = 1,
  RobotDrive_Mode_STOP = 2,
  RobotDrive_Mode_DRIVE = 3
};
bool RobotDrive_Mode_IsValid(int value);
constexpr RobotDrive_Mode RobotDrive_Mode_Mode_MIN = RobotDrive_Mode_FREE;
constexpr RobotDrive_Mode RobotDrive_Mode_Mode_MAX = RobotDrive_Mode_DRIVE;
constexpr int RobotDrive_Mode_Mode_ARRAYSIZE = RobotDrive_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotDrive_Mode_descriptor();
template<typename T>
inline const std::string& RobotDrive_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotDrive_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotDrive_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotDrive_Mode_descriptor(), enum_t_value);
}
inline bool RobotDrive_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotDrive_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotDrive_Mode>(
    RobotDrive_Mode_descriptor(), name, value);
}
enum RobotRequest_Wants : int {
  RobotRequest_Wants_NONE = 0,
  RobotRequest_Wants_POS = 1,
  RobotRequest_Wants_MAP = 2,
  RobotRequest_Wants_TRAIL = 4
};
bool RobotRequest_Wants_IsValid(int value);
constexpr RobotRequest_Wants RobotRequest_Wants_Wants_MIN = RobotRequest_Wants_NONE;
constexpr RobotRequest_Wants RobotRequest_Wants_Wants_MAX = RobotRequest_Wants_TRAIL;
constexpr int RobotRequest_Wants_Wants_ARRAYSIZE = RobotRequest_Wants_Wants_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotRequest_Wants_descriptor();
template<typename T>
inline const std::string& RobotRequest_Wants_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotRequest_Wants>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotRequest_Wants_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotRequest_Wants_descriptor(), enum_t_value);
}
inline bool RobotRequest_Wants_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotRequest_Wants* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotRequest_Wants>(
    RobotRequest_Wants_descriptor(), name, value);
}
enum RobotRequest_Action : int {
  RobotRequest_Action_NOOP = 0,
  RobotRequest_Action_POINT_APPLY = 1,
  RobotRequest_Action_NAVIGATION = 2,
  RobotRequest_Action_INIT_ORIGIN = 3,
  RobotRequest_Action_CREAT_MAP = 4,
  RobotRequest_Action_FINISH_MAP = 5
};
bool RobotRequest_Action_IsValid(int value);
constexpr RobotRequest_Action RobotRequest_Action_Action_MIN = RobotRequest_Action_NOOP;
constexpr RobotRequest_Action RobotRequest_Action_Action_MAX = RobotRequest_Action_FINISH_MAP;
constexpr int RobotRequest_Action_Action_ARRAYSIZE = RobotRequest_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotRequest_Action_descriptor();
template<typename T>
inline const std::string& RobotRequest_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotRequest_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotRequest_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotRequest_Action_descriptor(), enum_t_value);
}
inline bool RobotRequest_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotRequest_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotRequest_Action>(
    RobotRequest_Action_descriptor(), name, value);
}
enum RobotMap_Grid : int {
  RobotMap_Grid_UNKOWN = 0,
  RobotMap_Grid_FREE = 1,
  RobotMap_Grid_OCCUPIED = 2,
  RobotMap_Grid_FEATURE = 3
};
bool RobotMap_Grid_IsValid(int value);
constexpr RobotMap_Grid RobotMap_Grid_Grid_MIN = RobotMap_Grid_UNKOWN;
constexpr RobotMap_Grid RobotMap_Grid_Grid_MAX = RobotMap_Grid_FEATURE;
constexpr int RobotMap_Grid_Grid_ARRAYSIZE = RobotMap_Grid_Grid_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotMap_Grid_descriptor();
template<typename T>
inline const std::string& RobotMap_Grid_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotMap_Grid>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotMap_Grid_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotMap_Grid_descriptor(), enum_t_value);
}
inline bool RobotMap_Grid_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotMap_Grid* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotMap_Grid>(
    RobotMap_Grid_descriptor(), name, value);
}
// ===================================================================

class RobotDrive PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotDrive) */ {
 public:
  inline RobotDrive() : RobotDrive(nullptr) {};
  virtual ~RobotDrive();

  RobotDrive(const RobotDrive& from);
  RobotDrive(RobotDrive&& from) noexcept
    : RobotDrive() {
    *this = ::std::move(from);
  }

  inline RobotDrive& operator=(const RobotDrive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotDrive& operator=(RobotDrive&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotDrive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotDrive* internal_default_instance() {
    return reinterpret_cast<const RobotDrive*>(
               &_RobotDrive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotDrive& a, RobotDrive& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotDrive* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotDrive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotDrive* New() const final {
    return CreateMaybeMessage<RobotDrive>(nullptr);
  }

  RobotDrive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotDrive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotDrive& from);
  void MergeFrom(const RobotDrive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotDrive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotDrive";
  }
  protected:
  explicit RobotDrive(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RobotDrive_Mode Mode;
  static constexpr Mode FREE =
    RobotDrive_Mode_FREE;
  static constexpr Mode PAUSE =
    RobotDrive_Mode_PAUSE;
  static constexpr Mode STOP =
    RobotDrive_Mode_STOP;
  static constexpr Mode DRIVE =
    RobotDrive_Mode_DRIVE;
  static inline bool Mode_IsValid(int value) {
    return RobotDrive_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    RobotDrive_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    RobotDrive_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    RobotDrive_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return RobotDrive_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return RobotDrive_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return RobotDrive_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAngleFieldNumber = 3,
  };
  // required .RobotDrive.Mode mode = 1;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::RobotDrive_Mode mode() const;
  void set_mode(::RobotDrive_Mode value);
  private:
  ::RobotDrive_Mode _internal_mode() const;
  void _internal_set_mode(::RobotDrive_Mode value);
  public:

  // optional float speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // optional float angle = 3;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:RobotDrive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int mode_;
  float speed_;
  float angle_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class MitionPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MitionPoint) */ {
 public:
  inline MitionPoint() : MitionPoint(nullptr) {};
  virtual ~MitionPoint();

  MitionPoint(const MitionPoint& from);
  MitionPoint(MitionPoint&& from) noexcept
    : MitionPoint() {
    *this = ::std::move(from);
  }

  inline MitionPoint& operator=(const MitionPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MitionPoint& operator=(MitionPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MitionPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MitionPoint* internal_default_instance() {
    return reinterpret_cast<const MitionPoint*>(
               &_MitionPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MitionPoint& a, MitionPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MitionPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MitionPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MitionPoint* New() const final {
    return CreateMaybeMessage<MitionPoint>(nullptr);
  }

  MitionPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MitionPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MitionPoint& from);
  void MergeFrom(const MitionPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MitionPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MitionPoint";
  }
  protected:
  explicit MitionPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kAttributeFieldNumber = 3,
    kMSpeedFieldNumber = 4,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required int32 attribute = 3;
  bool has_attribute() const;
  private:
  bool _internal_has_attribute() const;
  public:
  void clear_attribute();
  ::PROTOBUF_NAMESPACE_ID::int32 attribute() const;
  void set_attribute(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attribute() const;
  void _internal_set_attribute(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required float m_speed = 4;
  bool has_m_speed() const;
  private:
  bool _internal_has_m_speed() const;
  public:
  void clear_m_speed();
  float m_speed() const;
  void set_m_speed(float value);
  private:
  float _internal_m_speed() const;
  void _internal_set_m_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:MitionPoint)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  ::PROTOBUF_NAMESPACE_ID::int32 attribute_;
  float m_speed_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class OriginPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OriginPoint) */ {
 public:
  inline OriginPoint() : OriginPoint(nullptr) {};
  virtual ~OriginPoint();

  OriginPoint(const OriginPoint& from);
  OriginPoint(OriginPoint&& from) noexcept
    : OriginPoint() {
    *this = ::std::move(from);
  }

  inline OriginPoint& operator=(const OriginPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginPoint& operator=(OriginPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OriginPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OriginPoint* internal_default_instance() {
    return reinterpret_cast<const OriginPoint*>(
               &_OriginPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OriginPoint& a, OriginPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(OriginPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OriginPoint* New() const final {
    return CreateMaybeMessage<OriginPoint>(nullptr);
  }

  OriginPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OriginPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OriginPoint& from);
  void MergeFrom(const OriginPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OriginPoint";
  }
  protected:
  explicit OriginPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:OriginPoint)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RobotRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotRequest) */ {
 public:
  inline RobotRequest() : RobotRequest(nullptr) {};
  virtual ~RobotRequest();

  RobotRequest(const RobotRequest& from);
  RobotRequest(RobotRequest&& from) noexcept
    : RobotRequest() {
    *this = ::std::move(from);
  }

  inline RobotRequest& operator=(const RobotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotRequest& operator=(RobotRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotRequest* internal_default_instance() {
    return reinterpret_cast<const RobotRequest*>(
               &_RobotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RobotRequest& a, RobotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotRequest* New() const final {
    return CreateMaybeMessage<RobotRequest>(nullptr);
  }

  RobotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotRequest& from);
  void MergeFrom(const RobotRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotRequest";
  }
  protected:
  explicit RobotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RobotRequest_Wants Wants;
  static constexpr Wants NONE =
    RobotRequest_Wants_NONE;
  static constexpr Wants POS =
    RobotRequest_Wants_POS;
  static constexpr Wants MAP =
    RobotRequest_Wants_MAP;
  static constexpr Wants TRAIL =
    RobotRequest_Wants_TRAIL;
  static inline bool Wants_IsValid(int value) {
    return RobotRequest_Wants_IsValid(value);
  }
  static constexpr Wants Wants_MIN =
    RobotRequest_Wants_Wants_MIN;
  static constexpr Wants Wants_MAX =
    RobotRequest_Wants_Wants_MAX;
  static constexpr int Wants_ARRAYSIZE =
    RobotRequest_Wants_Wants_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Wants_descriptor() {
    return RobotRequest_Wants_descriptor();
  }
  template<typename T>
  static inline const std::string& Wants_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Wants>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Wants_Name.");
    return RobotRequest_Wants_Name(enum_t_value);
  }
  static inline bool Wants_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Wants* value) {
    return RobotRequest_Wants_Parse(name, value);
  }

  typedef RobotRequest_Action Action;
  static constexpr Action NOOP =
    RobotRequest_Action_NOOP;
  static constexpr Action POINT_APPLY =
    RobotRequest_Action_POINT_APPLY;
  static constexpr Action NAVIGATION =
    RobotRequest_Action_NAVIGATION;
  static constexpr Action INIT_ORIGIN =
    RobotRequest_Action_INIT_ORIGIN;
  static constexpr Action CREAT_MAP =
    RobotRequest_Action_CREAT_MAP;
  static constexpr Action FINISH_MAP =
    RobotRequest_Action_FINISH_MAP;
  static inline bool Action_IsValid(int value) {
    return RobotRequest_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    RobotRequest_Action_Action_MIN;
  static constexpr Action Action_MAX =
    RobotRequest_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    RobotRequest_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return RobotRequest_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return RobotRequest_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return RobotRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 5,
    kTokenFieldNumber = 1,
    kDriveFieldNumber = 4,
    kOriginFieldNumber = 6,
    kWantsFieldNumber = 2,
    kActionFieldNumber = 3,
    kConfirmFieldNumber = 7,
  };
  // repeated .MitionPoint point = 5;
  int point_size() const;
  private:
  int _internal_point_size() const;
  public:
  void clear_point();
  ::MitionPoint* mutable_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MitionPoint >*
      mutable_point();
  private:
  const ::MitionPoint& _internal_point(int index) const;
  ::MitionPoint* _internal_add_point();
  public:
  const ::MitionPoint& point(int index) const;
  ::MitionPoint* add_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MitionPoint >&
      point() const;

  // required bytes token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional .RobotDrive drive = 4;
  bool has_drive() const;
  private:
  bool _internal_has_drive() const;
  public:
  void clear_drive();
  const ::RobotDrive& drive() const;
  ::RobotDrive* release_drive();
  ::RobotDrive* mutable_drive();
  void set_allocated_drive(::RobotDrive* drive);
  private:
  const ::RobotDrive& _internal_drive() const;
  ::RobotDrive* _internal_mutable_drive();
  public:
  void unsafe_arena_set_allocated_drive(
      ::RobotDrive* drive);
  ::RobotDrive* unsafe_arena_release_drive();

  // optional .OriginPoint origin = 6;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::OriginPoint& origin() const;
  ::OriginPoint* release_origin();
  ::OriginPoint* mutable_origin();
  void set_allocated_origin(::OriginPoint* origin);
  private:
  const ::OriginPoint& _internal_origin() const;
  ::OriginPoint* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::OriginPoint* origin);
  ::OriginPoint* unsafe_arena_release_origin();

  // required int32 wants = 2;
  bool has_wants() const;
  private:
  bool _internal_has_wants() const;
  public:
  void clear_wants();
  ::PROTOBUF_NAMESPACE_ID::int32 wants() const;
  void set_wants(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wants() const;
  void _internal_set_wants(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::PROTOBUF_NAMESPACE_ID::int32 action() const;
  void set_action(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_action() const;
  void _internal_set_action(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 confirm = 7;
  bool has_confirm() const;
  private:
  bool _internal_has_confirm() const;
  public:
  void clear_confirm();
  ::PROTOBUF_NAMESPACE_ID::int32 confirm() const;
  void set_confirm(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_confirm() const;
  void _internal_set_confirm(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RobotRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MitionPoint > point_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::RobotDrive* drive_;
  ::OriginPoint* origin_;
  ::PROTOBUF_NAMESPACE_ID::int32 wants_;
  ::PROTOBUF_NAMESPACE_ID::int32 action_;
  ::PROTOBUF_NAMESPACE_ID::int32 confirm_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RobotMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotMap) */ {
 public:
  inline RobotMap() : RobotMap(nullptr) {};
  virtual ~RobotMap();

  RobotMap(const RobotMap& from);
  RobotMap(RobotMap&& from) noexcept
    : RobotMap() {
    *this = ::std::move(from);
  }

  inline RobotMap& operator=(const RobotMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMap& operator=(RobotMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotMap* internal_default_instance() {
    return reinterpret_cast<const RobotMap*>(
               &_RobotMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotMap& a, RobotMap& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotMap* New() const final {
    return CreateMaybeMessage<RobotMap>(nullptr);
  }

  RobotMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotMap& from);
  void MergeFrom(const RobotMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotMap";
  }
  protected:
  explicit RobotMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RobotMap_Grid Grid;
  static constexpr Grid UNKOWN =
    RobotMap_Grid_UNKOWN;
  static constexpr Grid FREE =
    RobotMap_Grid_FREE;
  static constexpr Grid OCCUPIED =
    RobotMap_Grid_OCCUPIED;
  static constexpr Grid FEATURE =
    RobotMap_Grid_FEATURE;
  static inline bool Grid_IsValid(int value) {
    return RobotMap_Grid_IsValid(value);
  }
  static constexpr Grid Grid_MIN =
    RobotMap_Grid_Grid_MIN;
  static constexpr Grid Grid_MAX =
    RobotMap_Grid_Grid_MAX;
  static constexpr int Grid_ARRAYSIZE =
    RobotMap_Grid_Grid_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Grid_descriptor() {
    return RobotMap_Grid_descriptor();
  }
  template<typename T>
  static inline const std::string& Grid_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Grid>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Grid_Name.");
    return RobotMap_Grid_Name(enum_t_value);
  }
  static inline bool Grid_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Grid* value) {
    return RobotMap_Grid_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kZgridsFieldNumber = 6,
    kOriginXFieldNumber = 1,
    kOriginYFieldNumber = 2,
    kSizeFieldNumber = 3,
    kGridsXFieldNumber = 4,
    kGridsYFieldNumber = 5,
  };
  // required bytes zgrids = 6;
  bool has_zgrids() const;
  private:
  bool _internal_has_zgrids() const;
  public:
  void clear_zgrids();
  const std::string& zgrids() const;
  void set_zgrids(const std::string& value);
  void set_zgrids(std::string&& value);
  void set_zgrids(const char* value);
  void set_zgrids(const void* value, size_t size);
  std::string* mutable_zgrids();
  std::string* release_zgrids();
  void set_allocated_zgrids(std::string* zgrids);
  private:
  const std::string& _internal_zgrids() const;
  void _internal_set_zgrids(const std::string& value);
  std::string* _internal_mutable_zgrids();
  public:

  // required double origin_x = 1;
  bool has_origin_x() const;
  private:
  bool _internal_has_origin_x() const;
  public:
  void clear_origin_x();
  double origin_x() const;
  void set_origin_x(double value);
  private:
  double _internal_origin_x() const;
  void _internal_set_origin_x(double value);
  public:

  // required double origin_y = 2;
  bool has_origin_y() const;
  private:
  bool _internal_has_origin_y() const;
  public:
  void clear_origin_y();
  double origin_y() const;
  void set_origin_y(double value);
  private:
  double _internal_origin_y() const;
  void _internal_set_origin_y(double value);
  public:

  // required int32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 grids_x = 4;
  bool has_grids_x() const;
  private:
  bool _internal_has_grids_x() const;
  public:
  void clear_grids_x();
  ::PROTOBUF_NAMESPACE_ID::int32 grids_x() const;
  void set_grids_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_grids_x() const;
  void _internal_set_grids_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 grids_y = 5;
  bool has_grids_y() const;
  private:
  bool _internal_has_grids_y() const;
  public:
  void clear_grids_y();
  ::PROTOBUF_NAMESPACE_ID::int32 grids_y() const;
  void set_grids_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_grids_y() const;
  void _internal_set_grids_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RobotMap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zgrids_;
  double origin_x_;
  double origin_y_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  ::PROTOBUF_NAMESPACE_ID::int32 grids_x_;
  ::PROTOBUF_NAMESPACE_ID::int32 grids_y_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RobotPos PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotPos) */ {
 public:
  inline RobotPos() : RobotPos(nullptr) {};
  virtual ~RobotPos();

  RobotPos(const RobotPos& from);
  RobotPos(RobotPos&& from) noexcept
    : RobotPos() {
    *this = ::std::move(from);
  }

  inline RobotPos& operator=(const RobotPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPos& operator=(RobotPos&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotPos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotPos* internal_default_instance() {
    return reinterpret_cast<const RobotPos*>(
               &_RobotPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RobotPos& a, RobotPos& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPos* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotPos* New() const final {
    return CreateMaybeMessage<RobotPos>(nullptr);
  }

  RobotPos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotPos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotPos& from);
  void MergeFrom(const RobotPos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotPos";
  }
  protected:
  explicit RobotPos(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetXFieldNumber = 1,
    kOffsetYFieldNumber = 2,
    kAngleFieldNumber = 3,
  };
  // required float offset_x = 1;
  bool has_offset_x() const;
  private:
  bool _internal_has_offset_x() const;
  public:
  void clear_offset_x();
  float offset_x() const;
  void set_offset_x(float value);
  private:
  float _internal_offset_x() const;
  void _internal_set_offset_x(float value);
  public:

  // required float offset_y = 2;
  bool has_offset_y() const;
  private:
  bool _internal_has_offset_y() const;
  public:
  void clear_offset_y();
  float offset_y() const;
  void set_offset_y(float value);
  private:
  float _internal_offset_y() const;
  void _internal_set_offset_y(float value);
  public:

  // optional float angle = 3;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:RobotPos)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float offset_x_;
  float offset_y_;
  float angle_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RobotTrail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotTrail) */ {
 public:
  inline RobotTrail() : RobotTrail(nullptr) {};
  virtual ~RobotTrail();

  RobotTrail(const RobotTrail& from);
  RobotTrail(RobotTrail&& from) noexcept
    : RobotTrail() {
    *this = ::std::move(from);
  }

  inline RobotTrail& operator=(const RobotTrail& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotTrail& operator=(RobotTrail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotTrail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotTrail* internal_default_instance() {
    return reinterpret_cast<const RobotTrail*>(
               &_RobotTrail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RobotTrail& a, RobotTrail& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotTrail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotTrail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotTrail* New() const final {
    return CreateMaybeMessage<RobotTrail>(nullptr);
  }

  RobotTrail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotTrail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotTrail& from);
  void MergeFrom(const RobotTrail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotTrail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotTrail";
  }
  protected:
  explicit RobotTrail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrailFieldNumber = 1,
  };
  // repeated .RobotPos trail = 1;
  int trail_size() const;
  private:
  int _internal_trail_size() const;
  public:
  void clear_trail();
  ::RobotPos* mutable_trail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotPos >*
      mutable_trail();
  private:
  const ::RobotPos& _internal_trail(int index) const;
  ::RobotPos* _internal_add_trail();
  public:
  const ::RobotPos& trail(int index) const;
  ::RobotPos* add_trail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotPos >&
      trail() const;

  // @@protoc_insertion_point(class_scope:RobotTrail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotPos > trail_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RobotInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotInfo) */ {
 public:
  inline RobotInfo() : RobotInfo(nullptr) {};
  virtual ~RobotInfo();

  RobotInfo(const RobotInfo& from);
  RobotInfo(RobotInfo&& from) noexcept
    : RobotInfo() {
    *this = ::std::move(from);
  }

  inline RobotInfo& operator=(const RobotInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotInfo& operator=(RobotInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotInfo* internal_default_instance() {
    return reinterpret_cast<const RobotInfo*>(
               &_RobotInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RobotInfo& a, RobotInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotInfo* New() const final {
    return CreateMaybeMessage<RobotInfo>(nullptr);
  }

  RobotInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotInfo& from);
  void MergeFrom(const RobotInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotInfo";
  }
  protected:
  explicit RobotInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 1,
    kVoltageFieldNumber = 2,
    kCurXFieldNumber = 3,
    kCurYFieldNumber = 4,
    kCurYawFieldNumber = 5,
  };
  // required float speed = 1;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // required float voltage = 2;
  bool has_voltage() const;
  private:
  bool _internal_has_voltage() const;
  public:
  void clear_voltage();
  float voltage() const;
  void set_voltage(float value);
  private:
  float _internal_voltage() const;
  void _internal_set_voltage(float value);
  public:

  // required float cur_x = 3;
  bool has_cur_x() const;
  private:
  bool _internal_has_cur_x() const;
  public:
  void clear_cur_x();
  float cur_x() const;
  void set_cur_x(float value);
  private:
  float _internal_cur_x() const;
  void _internal_set_cur_x(float value);
  public:

  // required float cur_y = 4;
  bool has_cur_y() const;
  private:
  bool _internal_has_cur_y() const;
  public:
  void clear_cur_y();
  float cur_y() const;
  void set_cur_y(float value);
  private:
  float _internal_cur_y() const;
  void _internal_set_cur_y(float value);
  public:

  // required float cur_yaw = 5;
  bool has_cur_yaw() const;
  private:
  bool _internal_has_cur_yaw() const;
  public:
  void clear_cur_yaw();
  float cur_yaw() const;
  void set_cur_yaw(float value);
  private:
  float _internal_cur_yaw() const;
  void _internal_set_cur_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:RobotInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float speed_;
  float voltage_;
  float cur_x_;
  float cur_y_;
  float cur_yaw_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class MitionStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MitionStatus) */ {
 public:
  inline MitionStatus() : MitionStatus(nullptr) {};
  virtual ~MitionStatus();

  MitionStatus(const MitionStatus& from);
  MitionStatus(MitionStatus&& from) noexcept
    : MitionStatus() {
    *this = ::std::move(from);
  }

  inline MitionStatus& operator=(const MitionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MitionStatus& operator=(MitionStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MitionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MitionStatus* internal_default_instance() {
    return reinterpret_cast<const MitionStatus*>(
               &_MitionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MitionStatus& a, MitionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MitionStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MitionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MitionStatus* New() const final {
    return CreateMaybeMessage<MitionStatus>(nullptr);
  }

  MitionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MitionStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MitionStatus& from);
  void MergeFrom(const MitionStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MitionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MitionStatus";
  }
  protected:
  explicit MitionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMitionNumberFieldNumber = 1,
    kMitionFinishFieldNumber = 2,
  };
  // required int32 mition_number = 1;
  bool has_mition_number() const;
  private:
  bool _internal_has_mition_number() const;
  public:
  void clear_mition_number();
  ::PROTOBUF_NAMESPACE_ID::int32 mition_number() const;
  void set_mition_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mition_number() const;
  void _internal_set_mition_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool mition_finish = 2;
  bool has_mition_finish() const;
  private:
  bool _internal_has_mition_finish() const;
  public:
  void clear_mition_finish();
  bool mition_finish() const;
  void set_mition_finish(bool value);
  private:
  bool _internal_mition_finish() const;
  void _internal_set_mition_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MitionStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 mition_number_;
  bool mition_finish_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RobotResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RobotResponse) */ {
 public:
  inline RobotResponse() : RobotResponse(nullptr) {};
  virtual ~RobotResponse();

  RobotResponse(const RobotResponse& from);
  RobotResponse(RobotResponse&& from) noexcept
    : RobotResponse() {
    *this = ::std::move(from);
  }

  inline RobotResponse& operator=(const RobotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotResponse& operator=(RobotResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotResponse* internal_default_instance() {
    return reinterpret_cast<const RobotResponse*>(
               &_RobotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RobotResponse& a, RobotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotResponse* New() const final {
    return CreateMaybeMessage<RobotResponse>(nullptr);
  }

  RobotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotResponse& from);
  void MergeFrom(const RobotResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RobotResponse";
  }
  protected:
  explicit RobotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kPosFieldNumber = 3,
    kMapFieldNumber = 4,
    kTrailFieldNumber = 5,
    kPointFieldNumber = 6,
    kStatusFieldNumber = 7,
    kMitionFieldNumber = 8,
    kCodeFieldNumber = 1,
  };
  // optional string info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // optional .RobotPos pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::RobotPos& pos() const;
  ::RobotPos* release_pos();
  ::RobotPos* mutable_pos();
  void set_allocated_pos(::RobotPos* pos);
  private:
  const ::RobotPos& _internal_pos() const;
  ::RobotPos* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::RobotPos* pos);
  ::RobotPos* unsafe_arena_release_pos();

  // optional .RobotMap map = 4;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::RobotMap& map() const;
  ::RobotMap* release_map();
  ::RobotMap* mutable_map();
  void set_allocated_map(::RobotMap* map);
  private:
  const ::RobotMap& _internal_map() const;
  ::RobotMap* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::RobotMap* map);
  ::RobotMap* unsafe_arena_release_map();

  // optional .RobotTrail trail = 5;
  bool has_trail() const;
  private:
  bool _internal_has_trail() const;
  public:
  void clear_trail();
  const ::RobotTrail& trail() const;
  ::RobotTrail* release_trail();
  ::RobotTrail* mutable_trail();
  void set_allocated_trail(::RobotTrail* trail);
  private:
  const ::RobotTrail& _internal_trail() const;
  ::RobotTrail* _internal_mutable_trail();
  public:
  void unsafe_arena_set_allocated_trail(
      ::RobotTrail* trail);
  ::RobotTrail* unsafe_arena_release_trail();

  // optional .MitionPoint point = 6;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::MitionPoint& point() const;
  ::MitionPoint* release_point();
  ::MitionPoint* mutable_point();
  void set_allocated_point(::MitionPoint* point);
  private:
  const ::MitionPoint& _internal_point() const;
  ::MitionPoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::MitionPoint* point);
  ::MitionPoint* unsafe_arena_release_point();

  // optional .RobotInfo status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::RobotInfo& status() const;
  ::RobotInfo* release_status();
  ::RobotInfo* mutable_status();
  void set_allocated_status(::RobotInfo* status);
  private:
  const ::RobotInfo& _internal_status() const;
  ::RobotInfo* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::RobotInfo* status);
  ::RobotInfo* unsafe_arena_release_status();

  // optional .MitionStatus mition = 8;
  bool has_mition() const;
  private:
  bool _internal_has_mition() const;
  public:
  void clear_mition();
  const ::MitionStatus& mition() const;
  ::MitionStatus* release_mition();
  ::MitionStatus* mutable_mition();
  void set_allocated_mition(::MitionStatus* mition);
  private:
  const ::MitionStatus& _internal_mition() const;
  ::MitionStatus* _internal_mutable_mition();
  public:
  void unsafe_arena_set_allocated_mition(
      ::MitionStatus* mition);
  ::MitionStatus* unsafe_arena_release_mition();

  // required int32 code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:RobotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::RobotPos* pos_;
  ::RobotMap* map_;
  ::RobotTrail* trail_;
  ::MitionPoint* point_;
  ::RobotInfo* status_;
  ::MitionStatus* mition_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  friend struct ::TableStruct_robot_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotDrive

// required .RobotDrive.Mode mode = 1;
inline bool RobotDrive::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotDrive::has_mode() const {
  return _internal_has_mode();
}
inline void RobotDrive::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::RobotDrive_Mode RobotDrive::_internal_mode() const {
  return static_cast< ::RobotDrive_Mode >(mode_);
}
inline ::RobotDrive_Mode RobotDrive::mode() const {
  // @@protoc_insertion_point(field_get:RobotDrive.mode)
  return _internal_mode();
}
inline void RobotDrive::_internal_set_mode(::RobotDrive_Mode value) {
  assert(::RobotDrive_Mode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  mode_ = value;
}
inline void RobotDrive::set_mode(::RobotDrive_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:RobotDrive.mode)
}

// optional float speed = 2;
inline bool RobotDrive::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotDrive::has_speed() const {
  return _internal_has_speed();
}
inline void RobotDrive::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RobotDrive::_internal_speed() const {
  return speed_;
}
inline float RobotDrive::speed() const {
  // @@protoc_insertion_point(field_get:RobotDrive.speed)
  return _internal_speed();
}
inline void RobotDrive::_internal_set_speed(float value) {
  _has_bits_[0] |= 0x00000002u;
  speed_ = value;
}
inline void RobotDrive::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:RobotDrive.speed)
}

// optional float angle = 3;
inline bool RobotDrive::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotDrive::has_angle() const {
  return _internal_has_angle();
}
inline void RobotDrive::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float RobotDrive::_internal_angle() const {
  return angle_;
}
inline float RobotDrive::angle() const {
  // @@protoc_insertion_point(field_get:RobotDrive.angle)
  return _internal_angle();
}
inline void RobotDrive::_internal_set_angle(float value) {
  _has_bits_[0] |= 0x00000004u;
  angle_ = value;
}
inline void RobotDrive::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:RobotDrive.angle)
}

// -------------------------------------------------------------------

// MitionPoint

// required float x = 1;
inline bool MitionPoint::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MitionPoint::has_x() const {
  return _internal_has_x();
}
inline void MitionPoint::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MitionPoint::_internal_x() const {
  return x_;
}
inline float MitionPoint::x() const {
  // @@protoc_insertion_point(field_get:MitionPoint.x)
  return _internal_x();
}
inline void MitionPoint::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void MitionPoint::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:MitionPoint.x)
}

// required float y = 2;
inline bool MitionPoint::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MitionPoint::has_y() const {
  return _internal_has_y();
}
inline void MitionPoint::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MitionPoint::_internal_y() const {
  return y_;
}
inline float MitionPoint::y() const {
  // @@protoc_insertion_point(field_get:MitionPoint.y)
  return _internal_y();
}
inline void MitionPoint::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void MitionPoint::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:MitionPoint.y)
}

// required int32 attribute = 3;
inline bool MitionPoint::_internal_has_attribute() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MitionPoint::has_attribute() const {
  return _internal_has_attribute();
}
inline void MitionPoint::clear_attribute() {
  attribute_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MitionPoint::_internal_attribute() const {
  return attribute_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MitionPoint::attribute() const {
  // @@protoc_insertion_point(field_get:MitionPoint.attribute)
  return _internal_attribute();
}
inline void MitionPoint::_internal_set_attribute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  attribute_ = value;
}
inline void MitionPoint::set_attribute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attribute(value);
  // @@protoc_insertion_point(field_set:MitionPoint.attribute)
}

// required float m_speed = 4;
inline bool MitionPoint::_internal_has_m_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MitionPoint::has_m_speed() const {
  return _internal_has_m_speed();
}
inline void MitionPoint::clear_m_speed() {
  m_speed_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MitionPoint::_internal_m_speed() const {
  return m_speed_;
}
inline float MitionPoint::m_speed() const {
  // @@protoc_insertion_point(field_get:MitionPoint.m_speed)
  return _internal_m_speed();
}
inline void MitionPoint::_internal_set_m_speed(float value) {
  _has_bits_[0] |= 0x00000008u;
  m_speed_ = value;
}
inline void MitionPoint::set_m_speed(float value) {
  _internal_set_m_speed(value);
  // @@protoc_insertion_point(field_set:MitionPoint.m_speed)
}

// -------------------------------------------------------------------

// OriginPoint

// required float x = 1;
inline bool OriginPoint::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OriginPoint::has_x() const {
  return _internal_has_x();
}
inline void OriginPoint::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float OriginPoint::_internal_x() const {
  return x_;
}
inline float OriginPoint::x() const {
  // @@protoc_insertion_point(field_get:OriginPoint.x)
  return _internal_x();
}
inline void OriginPoint::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void OriginPoint::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:OriginPoint.x)
}

// required float y = 2;
inline bool OriginPoint::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OriginPoint::has_y() const {
  return _internal_has_y();
}
inline void OriginPoint::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float OriginPoint::_internal_y() const {
  return y_;
}
inline float OriginPoint::y() const {
  // @@protoc_insertion_point(field_get:OriginPoint.y)
  return _internal_y();
}
inline void OriginPoint::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void OriginPoint::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:OriginPoint.y)
}

// required float z = 3;
inline bool OriginPoint::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OriginPoint::has_z() const {
  return _internal_has_z();
}
inline void OriginPoint::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float OriginPoint::_internal_z() const {
  return z_;
}
inline float OriginPoint::z() const {
  // @@protoc_insertion_point(field_get:OriginPoint.z)
  return _internal_z();
}
inline void OriginPoint::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void OriginPoint::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:OriginPoint.z)
}

// -------------------------------------------------------------------

// RobotRequest

// required bytes token = 1;
inline bool RobotRequest::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotRequest::has_token() const {
  return _internal_has_token();
}
inline void RobotRequest::clear_token() {
  token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RobotRequest::token() const {
  // @@protoc_insertion_point(field_get:RobotRequest.token)
  return _internal_token();
}
inline void RobotRequest::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:RobotRequest.token)
}
inline std::string* RobotRequest::mutable_token() {
  // @@protoc_insertion_point(field_mutable:RobotRequest.token)
  return _internal_mutable_token();
}
inline const std::string& RobotRequest::_internal_token() const {
  return token_.Get();
}
inline void RobotRequest::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotRequest::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RobotRequest.token)
}
inline void RobotRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RobotRequest.token)
}
inline void RobotRequest::set_token(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RobotRequest.token)
}
inline std::string* RobotRequest::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotRequest::release_token() {
  // @@protoc_insertion_point(field_release:RobotRequest.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.token)
}

// required int32 wants = 2;
inline bool RobotRequest::_internal_has_wants() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RobotRequest::has_wants() const {
  return _internal_has_wants();
}
inline void RobotRequest::clear_wants() {
  wants_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotRequest::_internal_wants() const {
  return wants_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotRequest::wants() const {
  // @@protoc_insertion_point(field_get:RobotRequest.wants)
  return _internal_wants();
}
inline void RobotRequest::_internal_set_wants(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  wants_ = value;
}
inline void RobotRequest::set_wants(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wants(value);
  // @@protoc_insertion_point(field_set:RobotRequest.wants)
}

// required int32 action = 3;
inline bool RobotRequest::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RobotRequest::has_action() const {
  return _internal_has_action();
}
inline void RobotRequest::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotRequest::_internal_action() const {
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotRequest::action() const {
  // @@protoc_insertion_point(field_get:RobotRequest.action)
  return _internal_action();
}
inline void RobotRequest::_internal_set_action(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  action_ = value;
}
inline void RobotRequest::set_action(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:RobotRequest.action)
}

// optional .RobotDrive drive = 4;
inline bool RobotRequest::_internal_has_drive() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || drive_ != nullptr);
  return value;
}
inline bool RobotRequest::has_drive() const {
  return _internal_has_drive();
}
inline void RobotRequest::clear_drive() {
  if (drive_ != nullptr) drive_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::RobotDrive& RobotRequest::_internal_drive() const {
  const ::RobotDrive* p = drive_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RobotDrive*>(
      &::_RobotDrive_default_instance_);
}
inline const ::RobotDrive& RobotRequest::drive() const {
  // @@protoc_insertion_point(field_get:RobotRequest.drive)
  return _internal_drive();
}
inline void RobotRequest::unsafe_arena_set_allocated_drive(
    ::RobotDrive* drive) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drive_);
  }
  drive_ = drive;
  if (drive) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotRequest.drive)
}
inline ::RobotDrive* RobotRequest::release_drive() {
  _has_bits_[0] &= ~0x00000002u;
  ::RobotDrive* temp = drive_;
  drive_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RobotDrive* RobotRequest::unsafe_arena_release_drive() {
  // @@protoc_insertion_point(field_release:RobotRequest.drive)
  _has_bits_[0] &= ~0x00000002u;
  ::RobotDrive* temp = drive_;
  drive_ = nullptr;
  return temp;
}
inline ::RobotDrive* RobotRequest::_internal_mutable_drive() {
  _has_bits_[0] |= 0x00000002u;
  if (drive_ == nullptr) {
    auto* p = CreateMaybeMessage<::RobotDrive>(GetArena());
    drive_ = p;
  }
  return drive_;
}
inline ::RobotDrive* RobotRequest::mutable_drive() {
  // @@protoc_insertion_point(field_mutable:RobotRequest.drive)
  return _internal_mutable_drive();
}
inline void RobotRequest::set_allocated_drive(::RobotDrive* drive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete drive_;
  }
  if (drive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(drive);
    if (message_arena != submessage_arena) {
      drive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drive, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  drive_ = drive;
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.drive)
}

// repeated .MitionPoint point = 5;
inline int RobotRequest::_internal_point_size() const {
  return point_.size();
}
inline int RobotRequest::point_size() const {
  return _internal_point_size();
}
inline void RobotRequest::clear_point() {
  point_.Clear();
}
inline ::MitionPoint* RobotRequest::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:RobotRequest.point)
  return point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MitionPoint >*
RobotRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:RobotRequest.point)
  return &point_;
}
inline const ::MitionPoint& RobotRequest::_internal_point(int index) const {
  return point_.Get(index);
}
inline const ::MitionPoint& RobotRequest::point(int index) const {
  // @@protoc_insertion_point(field_get:RobotRequest.point)
  return _internal_point(index);
}
inline ::MitionPoint* RobotRequest::_internal_add_point() {
  return point_.Add();
}
inline ::MitionPoint* RobotRequest::add_point() {
  // @@protoc_insertion_point(field_add:RobotRequest.point)
  return _internal_add_point();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MitionPoint >&
RobotRequest::point() const {
  // @@protoc_insertion_point(field_list:RobotRequest.point)
  return point_;
}

// optional .OriginPoint origin = 6;
inline bool RobotRequest::_internal_has_origin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || origin_ != nullptr);
  return value;
}
inline bool RobotRequest::has_origin() const {
  return _internal_has_origin();
}
inline void RobotRequest::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::OriginPoint& RobotRequest::_internal_origin() const {
  const ::OriginPoint* p = origin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::OriginPoint*>(
      &::_OriginPoint_default_instance_);
}
inline const ::OriginPoint& RobotRequest::origin() const {
  // @@protoc_insertion_point(field_get:RobotRequest.origin)
  return _internal_origin();
}
inline void RobotRequest::unsafe_arena_set_allocated_origin(
    ::OriginPoint* origin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_);
  }
  origin_ = origin;
  if (origin) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotRequest.origin)
}
inline ::OriginPoint* RobotRequest::release_origin() {
  _has_bits_[0] &= ~0x00000004u;
  ::OriginPoint* temp = origin_;
  origin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::OriginPoint* RobotRequest::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:RobotRequest.origin)
  _has_bits_[0] &= ~0x00000004u;
  ::OriginPoint* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::OriginPoint* RobotRequest::_internal_mutable_origin() {
  _has_bits_[0] |= 0x00000004u;
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::OriginPoint>(GetArena());
    origin_ = p;
  }
  return origin_;
}
inline ::OriginPoint* RobotRequest::mutable_origin() {
  // @@protoc_insertion_point(field_mutable:RobotRequest.origin)
  return _internal_mutable_origin();
}
inline void RobotRequest::set_allocated_origin(::OriginPoint* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.origin)
}

// optional int32 confirm = 7;
inline bool RobotRequest::_internal_has_confirm() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RobotRequest::has_confirm() const {
  return _internal_has_confirm();
}
inline void RobotRequest::clear_confirm() {
  confirm_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotRequest::_internal_confirm() const {
  return confirm_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotRequest::confirm() const {
  // @@protoc_insertion_point(field_get:RobotRequest.confirm)
  return _internal_confirm();
}
inline void RobotRequest::_internal_set_confirm(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  confirm_ = value;
}
inline void RobotRequest::set_confirm(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_confirm(value);
  // @@protoc_insertion_point(field_set:RobotRequest.confirm)
}

// -------------------------------------------------------------------

// RobotMap

// required double origin_x = 1;
inline bool RobotMap::_internal_has_origin_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotMap::has_origin_x() const {
  return _internal_has_origin_x();
}
inline void RobotMap::clear_origin_x() {
  origin_x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RobotMap::_internal_origin_x() const {
  return origin_x_;
}
inline double RobotMap::origin_x() const {
  // @@protoc_insertion_point(field_get:RobotMap.origin_x)
  return _internal_origin_x();
}
inline void RobotMap::_internal_set_origin_x(double value) {
  _has_bits_[0] |= 0x00000002u;
  origin_x_ = value;
}
inline void RobotMap::set_origin_x(double value) {
  _internal_set_origin_x(value);
  // @@protoc_insertion_point(field_set:RobotMap.origin_x)
}

// required double origin_y = 2;
inline bool RobotMap::_internal_has_origin_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotMap::has_origin_y() const {
  return _internal_has_origin_y();
}
inline void RobotMap::clear_origin_y() {
  origin_y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double RobotMap::_internal_origin_y() const {
  return origin_y_;
}
inline double RobotMap::origin_y() const {
  // @@protoc_insertion_point(field_get:RobotMap.origin_y)
  return _internal_origin_y();
}
inline void RobotMap::_internal_set_origin_y(double value) {
  _has_bits_[0] |= 0x00000004u;
  origin_y_ = value;
}
inline void RobotMap::set_origin_y(double value) {
  _internal_set_origin_y(value);
  // @@protoc_insertion_point(field_set:RobotMap.origin_y)
}

// required int32 size = 3;
inline bool RobotMap::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RobotMap::has_size() const {
  return _internal_has_size();
}
inline void RobotMap::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotMap::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotMap::size() const {
  // @@protoc_insertion_point(field_get:RobotMap.size)
  return _internal_size();
}
inline void RobotMap::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  size_ = value;
}
inline void RobotMap::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:RobotMap.size)
}

// required int32 grids_x = 4;
inline bool RobotMap::_internal_has_grids_x() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RobotMap::has_grids_x() const {
  return _internal_has_grids_x();
}
inline void RobotMap::clear_grids_x() {
  grids_x_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotMap::_internal_grids_x() const {
  return grids_x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotMap::grids_x() const {
  // @@protoc_insertion_point(field_get:RobotMap.grids_x)
  return _internal_grids_x();
}
inline void RobotMap::_internal_set_grids_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  grids_x_ = value;
}
inline void RobotMap::set_grids_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_grids_x(value);
  // @@protoc_insertion_point(field_set:RobotMap.grids_x)
}

// required int32 grids_y = 5;
inline bool RobotMap::_internal_has_grids_y() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RobotMap::has_grids_y() const {
  return _internal_has_grids_y();
}
inline void RobotMap::clear_grids_y() {
  grids_y_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotMap::_internal_grids_y() const {
  return grids_y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotMap::grids_y() const {
  // @@protoc_insertion_point(field_get:RobotMap.grids_y)
  return _internal_grids_y();
}
inline void RobotMap::_internal_set_grids_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  grids_y_ = value;
}
inline void RobotMap::set_grids_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_grids_y(value);
  // @@protoc_insertion_point(field_set:RobotMap.grids_y)
}

// required bytes zgrids = 6;
inline bool RobotMap::_internal_has_zgrids() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotMap::has_zgrids() const {
  return _internal_has_zgrids();
}
inline void RobotMap::clear_zgrids() {
  zgrids_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RobotMap::zgrids() const {
  // @@protoc_insertion_point(field_get:RobotMap.zgrids)
  return _internal_zgrids();
}
inline void RobotMap::set_zgrids(const std::string& value) {
  _internal_set_zgrids(value);
  // @@protoc_insertion_point(field_set:RobotMap.zgrids)
}
inline std::string* RobotMap::mutable_zgrids() {
  // @@protoc_insertion_point(field_mutable:RobotMap.zgrids)
  return _internal_mutable_zgrids();
}
inline const std::string& RobotMap::_internal_zgrids() const {
  return zgrids_.Get();
}
inline void RobotMap::_internal_set_zgrids(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  zgrids_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotMap::set_zgrids(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  zgrids_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RobotMap.zgrids)
}
inline void RobotMap::set_zgrids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  zgrids_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RobotMap.zgrids)
}
inline void RobotMap::set_zgrids(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  zgrids_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RobotMap.zgrids)
}
inline std::string* RobotMap::_internal_mutable_zgrids() {
  _has_bits_[0] |= 0x00000001u;
  return zgrids_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotMap::release_zgrids() {
  // @@protoc_insertion_point(field_release:RobotMap.zgrids)
  if (!_internal_has_zgrids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return zgrids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotMap::set_allocated_zgrids(std::string* zgrids) {
  if (zgrids != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  zgrids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), zgrids,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RobotMap.zgrids)
}

// -------------------------------------------------------------------

// RobotPos

// required float offset_x = 1;
inline bool RobotPos::_internal_has_offset_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotPos::has_offset_x() const {
  return _internal_has_offset_x();
}
inline void RobotPos::clear_offset_x() {
  offset_x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float RobotPos::_internal_offset_x() const {
  return offset_x_;
}
inline float RobotPos::offset_x() const {
  // @@protoc_insertion_point(field_get:RobotPos.offset_x)
  return _internal_offset_x();
}
inline void RobotPos::_internal_set_offset_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  offset_x_ = value;
}
inline void RobotPos::set_offset_x(float value) {
  _internal_set_offset_x(value);
  // @@protoc_insertion_point(field_set:RobotPos.offset_x)
}

// required float offset_y = 2;
inline bool RobotPos::_internal_has_offset_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotPos::has_offset_y() const {
  return _internal_has_offset_y();
}
inline void RobotPos::clear_offset_y() {
  offset_y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RobotPos::_internal_offset_y() const {
  return offset_y_;
}
inline float RobotPos::offset_y() const {
  // @@protoc_insertion_point(field_get:RobotPos.offset_y)
  return _internal_offset_y();
}
inline void RobotPos::_internal_set_offset_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  offset_y_ = value;
}
inline void RobotPos::set_offset_y(float value) {
  _internal_set_offset_y(value);
  // @@protoc_insertion_point(field_set:RobotPos.offset_y)
}

// optional float angle = 3;
inline bool RobotPos::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotPos::has_angle() const {
  return _internal_has_angle();
}
inline void RobotPos::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float RobotPos::_internal_angle() const {
  return angle_;
}
inline float RobotPos::angle() const {
  // @@protoc_insertion_point(field_get:RobotPos.angle)
  return _internal_angle();
}
inline void RobotPos::_internal_set_angle(float value) {
  _has_bits_[0] |= 0x00000004u;
  angle_ = value;
}
inline void RobotPos::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:RobotPos.angle)
}

// -------------------------------------------------------------------

// RobotTrail

// repeated .RobotPos trail = 1;
inline int RobotTrail::_internal_trail_size() const {
  return trail_.size();
}
inline int RobotTrail::trail_size() const {
  return _internal_trail_size();
}
inline void RobotTrail::clear_trail() {
  trail_.Clear();
}
inline ::RobotPos* RobotTrail::mutable_trail(int index) {
  // @@protoc_insertion_point(field_mutable:RobotTrail.trail)
  return trail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotPos >*
RobotTrail::mutable_trail() {
  // @@protoc_insertion_point(field_mutable_list:RobotTrail.trail)
  return &trail_;
}
inline const ::RobotPos& RobotTrail::_internal_trail(int index) const {
  return trail_.Get(index);
}
inline const ::RobotPos& RobotTrail::trail(int index) const {
  // @@protoc_insertion_point(field_get:RobotTrail.trail)
  return _internal_trail(index);
}
inline ::RobotPos* RobotTrail::_internal_add_trail() {
  return trail_.Add();
}
inline ::RobotPos* RobotTrail::add_trail() {
  // @@protoc_insertion_point(field_add:RobotTrail.trail)
  return _internal_add_trail();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RobotPos >&
RobotTrail::trail() const {
  // @@protoc_insertion_point(field_list:RobotTrail.trail)
  return trail_;
}

// -------------------------------------------------------------------

// RobotInfo

// required float speed = 1;
inline bool RobotInfo::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotInfo::has_speed() const {
  return _internal_has_speed();
}
inline void RobotInfo::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float RobotInfo::_internal_speed() const {
  return speed_;
}
inline float RobotInfo::speed() const {
  // @@protoc_insertion_point(field_get:RobotInfo.speed)
  return _internal_speed();
}
inline void RobotInfo::_internal_set_speed(float value) {
  _has_bits_[0] |= 0x00000001u;
  speed_ = value;
}
inline void RobotInfo::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:RobotInfo.speed)
}

// required float voltage = 2;
inline bool RobotInfo::_internal_has_voltage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotInfo::has_voltage() const {
  return _internal_has_voltage();
}
inline void RobotInfo::clear_voltage() {
  voltage_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RobotInfo::_internal_voltage() const {
  return voltage_;
}
inline float RobotInfo::voltage() const {
  // @@protoc_insertion_point(field_get:RobotInfo.voltage)
  return _internal_voltage();
}
inline void RobotInfo::_internal_set_voltage(float value) {
  _has_bits_[0] |= 0x00000002u;
  voltage_ = value;
}
inline void RobotInfo::set_voltage(float value) {
  _internal_set_voltage(value);
  // @@protoc_insertion_point(field_set:RobotInfo.voltage)
}

// required float cur_x = 3;
inline bool RobotInfo::_internal_has_cur_x() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotInfo::has_cur_x() const {
  return _internal_has_cur_x();
}
inline void RobotInfo::clear_cur_x() {
  cur_x_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float RobotInfo::_internal_cur_x() const {
  return cur_x_;
}
inline float RobotInfo::cur_x() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_x)
  return _internal_cur_x();
}
inline void RobotInfo::_internal_set_cur_x(float value) {
  _has_bits_[0] |= 0x00000004u;
  cur_x_ = value;
}
inline void RobotInfo::set_cur_x(float value) {
  _internal_set_cur_x(value);
  // @@protoc_insertion_point(field_set:RobotInfo.cur_x)
}

// required float cur_y = 4;
inline bool RobotInfo::_internal_has_cur_y() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RobotInfo::has_cur_y() const {
  return _internal_has_cur_y();
}
inline void RobotInfo::clear_cur_y() {
  cur_y_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float RobotInfo::_internal_cur_y() const {
  return cur_y_;
}
inline float RobotInfo::cur_y() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_y)
  return _internal_cur_y();
}
inline void RobotInfo::_internal_set_cur_y(float value) {
  _has_bits_[0] |= 0x00000008u;
  cur_y_ = value;
}
inline void RobotInfo::set_cur_y(float value) {
  _internal_set_cur_y(value);
  // @@protoc_insertion_point(field_set:RobotInfo.cur_y)
}

// required float cur_yaw = 5;
inline bool RobotInfo::_internal_has_cur_yaw() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RobotInfo::has_cur_yaw() const {
  return _internal_has_cur_yaw();
}
inline void RobotInfo::clear_cur_yaw() {
  cur_yaw_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float RobotInfo::_internal_cur_yaw() const {
  return cur_yaw_;
}
inline float RobotInfo::cur_yaw() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_yaw)
  return _internal_cur_yaw();
}
inline void RobotInfo::_internal_set_cur_yaw(float value) {
  _has_bits_[0] |= 0x00000010u;
  cur_yaw_ = value;
}
inline void RobotInfo::set_cur_yaw(float value) {
  _internal_set_cur_yaw(value);
  // @@protoc_insertion_point(field_set:RobotInfo.cur_yaw)
}

// -------------------------------------------------------------------

// MitionStatus

// required int32 mition_number = 1;
inline bool MitionStatus::_internal_has_mition_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MitionStatus::has_mition_number() const {
  return _internal_has_mition_number();
}
inline void MitionStatus::clear_mition_number() {
  mition_number_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MitionStatus::_internal_mition_number() const {
  return mition_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MitionStatus::mition_number() const {
  // @@protoc_insertion_point(field_get:MitionStatus.mition_number)
  return _internal_mition_number();
}
inline void MitionStatus::_internal_set_mition_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  mition_number_ = value;
}
inline void MitionStatus::set_mition_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mition_number(value);
  // @@protoc_insertion_point(field_set:MitionStatus.mition_number)
}

// required bool mition_finish = 2;
inline bool MitionStatus::_internal_has_mition_finish() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MitionStatus::has_mition_finish() const {
  return _internal_has_mition_finish();
}
inline void MitionStatus::clear_mition_finish() {
  mition_finish_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MitionStatus::_internal_mition_finish() const {
  return mition_finish_;
}
inline bool MitionStatus::mition_finish() const {
  // @@protoc_insertion_point(field_get:MitionStatus.mition_finish)
  return _internal_mition_finish();
}
inline void MitionStatus::_internal_set_mition_finish(bool value) {
  _has_bits_[0] |= 0x00000002u;
  mition_finish_ = value;
}
inline void MitionStatus::set_mition_finish(bool value) {
  _internal_set_mition_finish(value);
  // @@protoc_insertion_point(field_set:MitionStatus.mition_finish)
}

// -------------------------------------------------------------------

// RobotResponse

// required int32 code = 1;
inline bool RobotResponse::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RobotResponse::has_code() const {
  return _internal_has_code();
}
inline void RobotResponse::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RobotResponse::code() const {
  // @@protoc_insertion_point(field_get:RobotResponse.code)
  return _internal_code();
}
inline void RobotResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  code_ = value;
}
inline void RobotResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:RobotResponse.code)
}

// optional string info = 2;
inline bool RobotResponse::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotResponse::has_info() const {
  return _internal_has_info();
}
inline void RobotResponse::clear_info() {
  info_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RobotResponse::info() const {
  // @@protoc_insertion_point(field_get:RobotResponse.info)
  return _internal_info();
}
inline void RobotResponse::set_info(const std::string& value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:RobotResponse.info)
}
inline std::string* RobotResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.info)
  return _internal_mutable_info();
}
inline const std::string& RobotResponse::_internal_info() const {
  return info_.Get();
}
inline void RobotResponse::_internal_set_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotResponse::set_info(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  info_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:RobotResponse.info)
}
inline void RobotResponse::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:RobotResponse.info)
}
inline void RobotResponse::set_info(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:RobotResponse.info)
}
inline std::string* RobotResponse::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  return info_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotResponse::release_info() {
  // @@protoc_insertion_point(field_release:RobotResponse.info)
  if (!_internal_has_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotResponse::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.info)
}

// optional .RobotPos pos = 3;
inline bool RobotResponse::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || pos_ != nullptr);
  return value;
}
inline bool RobotResponse::has_pos() const {
  return _internal_has_pos();
}
inline void RobotResponse::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::RobotPos& RobotResponse::_internal_pos() const {
  const ::RobotPos* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RobotPos*>(
      &::_RobotPos_default_instance_);
}
inline const ::RobotPos& RobotResponse::pos() const {
  // @@protoc_insertion_point(field_get:RobotResponse.pos)
  return _internal_pos();
}
inline void RobotResponse::unsafe_arena_set_allocated_pos(
    ::RobotPos* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotResponse.pos)
}
inline ::RobotPos* RobotResponse::release_pos() {
  _has_bits_[0] &= ~0x00000002u;
  ::RobotPos* temp = pos_;
  pos_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RobotPos* RobotResponse::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:RobotResponse.pos)
  _has_bits_[0] &= ~0x00000002u;
  ::RobotPos* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::RobotPos* RobotResponse::_internal_mutable_pos() {
  _has_bits_[0] |= 0x00000002u;
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::RobotPos>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::RobotPos* RobotResponse::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.pos)
  return _internal_mutable_pos();
}
inline void RobotResponse::set_allocated_pos(::RobotPos* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.pos)
}

// optional .RobotMap map = 4;
inline bool RobotResponse::_internal_has_map() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || map_ != nullptr);
  return value;
}
inline bool RobotResponse::has_map() const {
  return _internal_has_map();
}
inline void RobotResponse::clear_map() {
  if (map_ != nullptr) map_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::RobotMap& RobotResponse::_internal_map() const {
  const ::RobotMap* p = map_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RobotMap*>(
      &::_RobotMap_default_instance_);
}
inline const ::RobotMap& RobotResponse::map() const {
  // @@protoc_insertion_point(field_get:RobotResponse.map)
  return _internal_map();
}
inline void RobotResponse::unsafe_arena_set_allocated_map(
    ::RobotMap* map) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map_);
  }
  map_ = map;
  if (map) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotResponse.map)
}
inline ::RobotMap* RobotResponse::release_map() {
  _has_bits_[0] &= ~0x00000004u;
  ::RobotMap* temp = map_;
  map_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RobotMap* RobotResponse::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:RobotResponse.map)
  _has_bits_[0] &= ~0x00000004u;
  ::RobotMap* temp = map_;
  map_ = nullptr;
  return temp;
}
inline ::RobotMap* RobotResponse::_internal_mutable_map() {
  _has_bits_[0] |= 0x00000004u;
  if (map_ == nullptr) {
    auto* p = CreateMaybeMessage<::RobotMap>(GetArena());
    map_ = p;
  }
  return map_;
}
inline ::RobotMap* RobotResponse::mutable_map() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.map)
  return _internal_mutable_map();
}
inline void RobotResponse::set_allocated_map(::RobotMap* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete map_;
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  map_ = map;
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.map)
}

// optional .RobotTrail trail = 5;
inline bool RobotResponse::_internal_has_trail() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || trail_ != nullptr);
  return value;
}
inline bool RobotResponse::has_trail() const {
  return _internal_has_trail();
}
inline void RobotResponse::clear_trail() {
  if (trail_ != nullptr) trail_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::RobotTrail& RobotResponse::_internal_trail() const {
  const ::RobotTrail* p = trail_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RobotTrail*>(
      &::_RobotTrail_default_instance_);
}
inline const ::RobotTrail& RobotResponse::trail() const {
  // @@protoc_insertion_point(field_get:RobotResponse.trail)
  return _internal_trail();
}
inline void RobotResponse::unsafe_arena_set_allocated_trail(
    ::RobotTrail* trail) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trail_);
  }
  trail_ = trail;
  if (trail) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotResponse.trail)
}
inline ::RobotTrail* RobotResponse::release_trail() {
  _has_bits_[0] &= ~0x00000008u;
  ::RobotTrail* temp = trail_;
  trail_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RobotTrail* RobotResponse::unsafe_arena_release_trail() {
  // @@protoc_insertion_point(field_release:RobotResponse.trail)
  _has_bits_[0] &= ~0x00000008u;
  ::RobotTrail* temp = trail_;
  trail_ = nullptr;
  return temp;
}
inline ::RobotTrail* RobotResponse::_internal_mutable_trail() {
  _has_bits_[0] |= 0x00000008u;
  if (trail_ == nullptr) {
    auto* p = CreateMaybeMessage<::RobotTrail>(GetArena());
    trail_ = p;
  }
  return trail_;
}
inline ::RobotTrail* RobotResponse::mutable_trail() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.trail)
  return _internal_mutable_trail();
}
inline void RobotResponse::set_allocated_trail(::RobotTrail* trail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trail_;
  }
  if (trail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trail);
    if (message_arena != submessage_arena) {
      trail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trail, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  trail_ = trail;
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.trail)
}

// optional .MitionPoint point = 6;
inline bool RobotResponse::_internal_has_point() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || point_ != nullptr);
  return value;
}
inline bool RobotResponse::has_point() const {
  return _internal_has_point();
}
inline void RobotResponse::clear_point() {
  if (point_ != nullptr) point_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::MitionPoint& RobotResponse::_internal_point() const {
  const ::MitionPoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MitionPoint*>(
      &::_MitionPoint_default_instance_);
}
inline const ::MitionPoint& RobotResponse::point() const {
  // @@protoc_insertion_point(field_get:RobotResponse.point)
  return _internal_point();
}
inline void RobotResponse::unsafe_arena_set_allocated_point(
    ::MitionPoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotResponse.point)
}
inline ::MitionPoint* RobotResponse::release_point() {
  _has_bits_[0] &= ~0x00000010u;
  ::MitionPoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MitionPoint* RobotResponse::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:RobotResponse.point)
  _has_bits_[0] &= ~0x00000010u;
  ::MitionPoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::MitionPoint* RobotResponse::_internal_mutable_point() {
  _has_bits_[0] |= 0x00000010u;
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::MitionPoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::MitionPoint* RobotResponse::mutable_point() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.point)
  return _internal_mutable_point();
}
inline void RobotResponse::set_allocated_point(::MitionPoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.point)
}

// optional .RobotInfo status = 7;
inline bool RobotResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool RobotResponse::has_status() const {
  return _internal_has_status();
}
inline void RobotResponse::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::RobotInfo& RobotResponse::_internal_status() const {
  const ::RobotInfo* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RobotInfo*>(
      &::_RobotInfo_default_instance_);
}
inline const ::RobotInfo& RobotResponse::status() const {
  // @@protoc_insertion_point(field_get:RobotResponse.status)
  return _internal_status();
}
inline void RobotResponse::unsafe_arena_set_allocated_status(
    ::RobotInfo* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotResponse.status)
}
inline ::RobotInfo* RobotResponse::release_status() {
  _has_bits_[0] &= ~0x00000020u;
  ::RobotInfo* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RobotInfo* RobotResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:RobotResponse.status)
  _has_bits_[0] &= ~0x00000020u;
  ::RobotInfo* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::RobotInfo* RobotResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000020u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::RobotInfo>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::RobotInfo* RobotResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.status)
  return _internal_mutable_status();
}
inline void RobotResponse::set_allocated_status(::RobotInfo* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.status)
}

// optional .MitionStatus mition = 8;
inline bool RobotResponse::_internal_has_mition() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || mition_ != nullptr);
  return value;
}
inline bool RobotResponse::has_mition() const {
  return _internal_has_mition();
}
inline void RobotResponse::clear_mition() {
  if (mition_ != nullptr) mition_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::MitionStatus& RobotResponse::_internal_mition() const {
  const ::MitionStatus* p = mition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MitionStatus*>(
      &::_MitionStatus_default_instance_);
}
inline const ::MitionStatus& RobotResponse::mition() const {
  // @@protoc_insertion_point(field_get:RobotResponse.mition)
  return _internal_mition();
}
inline void RobotResponse::unsafe_arena_set_allocated_mition(
    ::MitionStatus* mition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mition_);
  }
  mition_ = mition;
  if (mition) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RobotResponse.mition)
}
inline ::MitionStatus* RobotResponse::release_mition() {
  _has_bits_[0] &= ~0x00000040u;
  ::MitionStatus* temp = mition_;
  mition_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MitionStatus* RobotResponse::unsafe_arena_release_mition() {
  // @@protoc_insertion_point(field_release:RobotResponse.mition)
  _has_bits_[0] &= ~0x00000040u;
  ::MitionStatus* temp = mition_;
  mition_ = nullptr;
  return temp;
}
inline ::MitionStatus* RobotResponse::_internal_mutable_mition() {
  _has_bits_[0] |= 0x00000040u;
  if (mition_ == nullptr) {
    auto* p = CreateMaybeMessage<::MitionStatus>(GetArena());
    mition_ = p;
  }
  return mition_;
}
inline ::MitionStatus* RobotResponse::mutable_mition() {
  // @@protoc_insertion_point(field_mutable:RobotResponse.mition)
  return _internal_mutable_mition();
}
inline void RobotResponse::set_allocated_mition(::MitionStatus* mition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mition_;
  }
  if (mition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mition);
    if (message_arena != submessage_arena) {
      mition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  mition_ = mition;
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.mition)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RobotDrive_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotDrive_Mode>() {
  return ::RobotDrive_Mode_descriptor();
}
template <> struct is_proto_enum< ::RobotRequest_Wants> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotRequest_Wants>() {
  return ::RobotRequest_Wants_descriptor();
}
template <> struct is_proto_enum< ::RobotRequest_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotRequest_Action>() {
  return ::RobotRequest_Action_descriptor();
}
template <> struct is_proto_enum< ::RobotMap_Grid> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotMap_Grid>() {
  return ::RobotMap_Grid_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_2eproto
